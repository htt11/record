## 数值转换：Number() 、 parseInt() 、 parseFloat() :

`Number()`可以用于任何数据类型，而`parseInt()`和`parseFloat()`则专门用于把字符串转换为数值，这三个函数对于同样的输入会返回不同的结果。

### Number() 

转换规则如下：

- **Boolean值**：true 和 false 分别被转换为 1 和 0；

- **数字值**：只是简单的传入和返回；

- **null**：返回 0；

- **underfined**：返回NaN；

- **字符串**，遵循以下规则：

  - 字符串中只包含数字（包括前面带正号和负号的情况），转换为十进制数值；

    转换时前导的0会被省略，因此无法转换八进制数值；

    ```js
    Number('123')	// 123 
    Number('011')	// 11  注：前导的0被忽略了
    Number('00001')	// 1
    ```

  - 字符串中包含有效的十六进制格式，转换为相同大小的十进制整数值；

    ```js
    Number('0xf')	// 15 
    ```

  - 如果字符串是空的（不包含任何字符），转换为 0 ；

    ```js
    Number('')	// 0
    ```

  - 除上述格式之外的字符，被转换为 NaN ；

    ```js
    Number('Hello')		// NaN 
    Number('12a')		// NaN  
    ```

- **对象**：调用对象的`valueOf()`方法，然后按照前面的规则转换返回的值；如果转换的结果是`NaN`，则调用对象的`toString( )`方法，然后按照前面的规则转换返回的字符串值；

### parseInt() 

由于Number() 函数在转换字符串时比较复杂而且不合理，因此在处理整数的时候最常用的是`parseInt()`函数；

`parseInt()`函数在转换字符串时，更多的是看其是否符合数值模式；

- **它会忽略字符串前面的空格，直至找到第一个非空格字符**：

  ```js
  parseInt('    1234');		// 1234	
  ```

- **若第一个字符不是数字字符或负号，`parseInt()`会返回NaN**：

  也就是说，`parseInt()`转换空字符串会返回NaN，而Number()对空字符串返回0；

  ```js
  parseInt('');				// NaN
  parseInt('-1234');			// 1234	
  parseInt('a1234');			// NaN
  ```

- **若第一个字符是数字字符，会继续依次解析，直到解析完所有后续字符或者遇到了一个非数字字符**：

  - 若第一个字符是数字字符，parseInt()也能够识别出各种整数格式（八/十/十六进制）；

  ```js
  parseInt('1234blue');		// 1234
  parseInt('22.5');			// 22 (小数点不是有效的数字字符)
  
  parseInt('70');				// 70 (十进制数)
  parseInt('0xf');			// 15 (十六进制数)
  ```

  **注：**在使用parseInt()解析像八进制字面量的字符串时，ECMAScript 3和ECMAScript 5存在分歧：

  - 在ECMAScript 3 JS引擎中，'070'被当成八进制字面量，`parseInt('070')`转换后的值为十进制的`56`；

  - 而在ECMAScript 5 JS引擎中，parseInt()已经不具备解析八进制值的能力，因此前导的 0 会被认为无效，从而将这个值当成“70”，因此得到的值为十进制的`70`；在ECMAScript 5中，即使在非严格模式下也会如此；

  ```js
  // ECMAScript 3
  parseInt('070');			// 56
  // ECMAScript 5
  parseInt('070');			// 70
  ```

  - 为了消除在使用parseInt()函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换基数(即多少进制)；

  ```js
  parseInt('10', 2);			// 2
  parseInt('070', 8);			// 56
  parseInt('0xf', 16);		// 15
  ```

  - 实际上，如果指向了第二参数为 `8` 或 `16` ，字符串x可以不带前面的 `'0'` 或 `'0x'` ;

  ```js
  parseInt('70', 8);			// 56
  parseInt('f', 16);			// 15
  ```

  - 不指定基数就意味着让parseInt()决定如何解析输入的字符串，因此为了避免错误的解析，建议无论在什么情况下都明确指定基数；

###  parseFloat()

与 `parseInt()`类似，`parseFloat()`也是从第一个字符（位置0）开始依次解析每个字符，直到遇到一个无效的浮点数字字符或解析到字符串末尾为止；

- **字符串中的第一个小数点是有效的，而第二个小数点是无效的，因此会停止解析，忽略它后面的字符串；**

  ```js
  parseFloat('22.3');			// 22.3
  parseFloat('22.34.5');		// 22.34
  ```

- **除首个小数点有效之外，`parseFloat()`与 `parseInt()`的第二个区别在于它始终会忽略前导的零；**

  ```JS
  parseFloat('010');			// 10
  parseFloat('0908.5');		// 908.5
  ```

-  **`parseFloat()`只解析十进制值，因为它没有用第二个参数指定基数的用法；**

- **十六进制格式的字符串始终会转换为0；**

  ```js
  parseFloat('0xf');		// NaN
  ```

- **如果字符串中包含一个可解析为整数的数（没有小数点，或小数点后都是零）， `parseFloat()`会返回整数；**

  ```js
  parseFloat('1234blue');		// 1234
  parseFloat('3.125e7');		// 31250000
  ```


## Number 类型：

在ECMAScript中，Number类型使用IEEE754格式来表示**整数**和**浮点数值**（浮点数值在某些语言中也被称为双精度数值）；

为支持各种数值类型，ECMA-262定义了三种数值字面量格式（八进制、十进制、十六进制）：

- 八进制字面量的第一位必须是0，数字序列为 0~7，如果字面值中的数值超过了范围，那么前导 0 将被忽略，后面的值将被当作十进制解析；

  ```js
  var octalNum1 = 079;		// 无效得八进制数值，解析为79
  var octalNum2 = 08;			// 无效得八进制数值，解析为8
  ```

- 十六进制字面量值得前两位必须是 0x，后跟十六进制数字（0~9 及 A~F）。其中，字母 A~F 可以大写，也可以小写。

  ```js
  var octalNum1 = 0xA;			// 十进制得10
  var octalNum2 = 0x1f;			// 十进制得31
  ```

在进行算术计算时，所有的八进制和十六进制表示的数值最终都将被转换成十进制数值；

JavaScript中，可以保存正零（+0）和负零（-0），正零和负零被认为相等；

### 浮点数值：

所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一个数字；

虽然小数点前面可以没有整数，但我们不推荐这种写法；

```js
var floatNum1 = 1.1;
var floatNum1 = 0.1;
var floatNum2 = .1;		//有效，但不推荐
```

**ECMAScript会不失时机地将浮点数值转换为整数值：**

- 原因：保存浮点数值需要的内存空间是保存整数值的两倍；

- 若小数点后没有跟任何数字，那么这个数值就会作为整数来保存；

  ```js
  var floatNum1 = 1.;			// 小数点后没有数字 -- 解析为1
  var floatNum1 = 10.0;		// 整数 -- 解析为10
  ```

- 若浮点数本身表示的就是一个整数，那么该值也会被转换为整数；

**对于极大或极小的数值，可以用 e 表示法（即科学计数法）表示的浮点数值表示：**

- e 表示法表示的数值等于 e 前面的数值乘以 10 的指数次幂；

- e 前面的数值可以是整数也可以是浮点数，e 字母可大写可小写；]

  ```js
  var floatNum1 = 3.125e7;		// 等于31250000，即3.125*10^7
  var floatNum2 = 3.125e-7;		// 等于0.0000003125
  ```

- 默认情况下，ECMAScript会将小数点后带有6个零以上的浮点数值转换为以e表示法表示的数值（例：0.0000003会被转换为3e-7）；

  ```js
  var floatNum = 0.0000003;		// 3e-7
  ```

**浮点数值得最高精度是17位小数，但在进行算术计算时其精确度远不如整数：**

- 这个小小的舍入误差会导致无法测试特定的浮点数值；

  - 如果两个数是 0.1 和 0.2 ，测试将无法通过；

  ```js
  var floatNum = 0.1 + 0.2;		// 0.30000000000000004
  
  var a = 0.1;
  var b = 0.2;
  if (a + b) {
      alert('You got 0.3');		// 不要做这样的测试
  }
  ```

  - 关于浮点数值计算会产生舍入误差的问题，这是使用IEEE754 数值的浮点计算的通病，其他使用相同数值格式的语言也存在这个问题，ECMAScript并非独此一家；

### 数值范围：

**由于内存的限制，ECMAScript 并不能保存世界上所有的值**，在ECMAScript 中：

- 能够表示的最小数值保存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324；
- 能够表示的最大数值保存在 Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308；

**如果某次的计算结果超过了 JavaScript 数值范围的值，那么这个值将会被自动转换为特殊的 Infinity 值：**

- 如果数值是正数，被转换为**Infinity**（正无穷）；
- 如果数值是负数，被转换为**-Infinity**（负无穷）；
  
### NaN：

NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）：

- 在其他编程语言中，任何数值除以非数值都会导致错误，从而停止代码执行；
- 在 ECMAScript 中，任何数值除以非数值都会返回 NaN，因此不影响其他代码的执行；

**NaN 本身具有的特点：**

- <u>任何涉及 NaN  的操作（如 NaN/20）都会返回 NaN</u>，这个特点在多步计算中有可能导致问题；
- <u>NaN 与任何值都不相等，包括 NaN 本身</u>；

**isNaN() 函数**：isNaN() 在接收到一个值之后，会尝试将这个值转换为数值。

- 某些不是数值的值会被直接转换为数值；

  ```js
  isNaN(10);		// false，10是一个数值
  isNaN('10');	// false，字符串'10'可以被转换为数值10
  isNaN(true);	// false，Boolean值true可以被转换为数值1
  ```

- 任何不能被转换为数值的值都会导致这个函数返回 true；

  ```js
  isNaN(NaN);		// true
  isNaN('blue');	// true
  isNaN('10a');	// true
  ```

- **isNaN 也适用于对象**，在基于对象调用时，会首先调用对象的 valueOf() 方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用 toString() 方法，再测试返回值。（这个过程也是ECMAScript中内置函数和操作符的一般执行流程）
