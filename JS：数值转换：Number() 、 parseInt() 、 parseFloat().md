## 数值转换：Number() 、 parseInt() 、 parseFloat() :

`Number()`可以用于任何数据类型，而`parseInt()`和`parseFloat()`则专门用于把字符串转换为数值，这三个函数对于同样的输入会返回不同的结果。

### Number() 

转换规则如下：

- **Boolean值**：true 和 false 分别被转换为 1 和 0；

- **数字值**：只是简单的传入和返回；

- **null**：返回 0；

- **underfined**：返回NaN；

- **字符串**，遵循以下规则：

  - 字符串中只包含数字（包括前面带正号和负号的情况），转换为十进制数值；

    转换时前导的0会被省略，因此无法转换八进制数值；

    ```js
    Number('123')	// 123 
    Number('011')	// 11  注：前导的0被忽略了
    Number('00001')	// 1
    ```

  - 字符串中包含有效的十六进制格式，转换为相同大小的十进制整数值；

    ```js
    Number('0xf')	// 15 
    ```

  - 如果字符串是空的（不包含任何字符），转换为 0 ；

    ```js
    Number('')	// 0
    ```

  - 除上述格式之外的字符，被转换为 NaN ；

    ```js
    Number('Hello')		// NaN 
    Number('12a')		// NaN  
    ```

- **对象**：调用对象的`valueOf()`方法，然后按照前面的规则转换返回的值；如果转换的结果是`NaN`，则调用对象的`toString( )`方法，然后按照前面的规则转换返回的字符串值；

### parseInt() 

由于Number() 函数在转换字符串时比较复杂而且不合理，因此在处理整数的时候最常用的是`parseInt()`函数；

`parseInt()`函数在转换字符串时，更多的是看其是否符合数值模式；

- **它会忽略字符串前面的空格，直至找到第一个非空格字符**：

  ```js
  parseInt('    1234');		// 1234	
  ```

- **若第一个字符不是数字字符或负号，`parseInt()`会返回NaN**：

  也就是说，`parseInt()`转换空字符串会返回NaN，而Number()对空字符串返回0；

  ```js
  parseInt('');				// NaN
  parseInt('-1234');			// 1234	
  parseInt('a1234');			// NaN
  ```

- **若第一个字符是数字字符，会继续依次解析，直到解析完所有后续字符或者遇到了一个非数字字符**：

  - 若第一个字符是数字字符，parseInt()也能够识别出各种整数格式（八/十/十六进制）；

  ```js
  parseInt('1234blue');		// 1234
  parseInt('22.5');			// 22 (小数点不是有效的数字字符)
  
  parseInt('70');				// 70 (十进制数)
  parseInt('0xf');			// 15 (十六进制数)
  ```

  **注：**在使用parseInt()解析像八进制字面量的字符串时，ECMAScript 3和ECMAScript 5存在分歧：

  - 在ECMAScript 3 JS引擎中，'070'被当成八进制字面量，`parseInt('070')`转换后的值为十进制的`56`；

  - 而在ECMAScript 5 JS引擎中，parseInt()已经不具备解析八进制值的能力，因此前导的 0 会被认为无效，从而将这个值当成“70”，因此得到的值为十进制的`70`；在ECMAScript 5中，即使在非严格模式下也会如此；

  ```js
  // ECMAScript 3
  parseInt('070');			// 56
  // ECMAScript 5
  parseInt('070');			// 70
  ```

  - 为了消除在使用parseInt()函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换基数(即多少进制)；

  ```js
  parseInt('10', 2);			// 2
  parseInt('070', 8);			// 56
  parseInt('0xf', 16);		// 15
  ```

  - 实际上，如果指向了第二参数为 `8` 或 `16` ，字符串x可以不带前面的 `'0'` 或 `'0x'` ;

  ```js
  parseInt('70', 8);			// 56
  parseInt('f', 16);			// 15
  ```

  - 不指定基数就意味着让parseInt()决定如何解析输入的字符串，因此为了避免错误的解析，建议无论在什么情况下都明确指定基数；

###  parseFloat()

与 `parseInt()`类似，`parseFloat()`也是从第一个字符（位置0）开始依次解析每个字符，直到遇到一个无效的浮点数字字符或解析到字符串末尾为止；

- **字符串中的第一个小数点是有效的，而第二个小数点是无效的，因此会停止解析，忽略它后面的字符串；**

  ```js
  parseFloat('22.3');			// 22.3
  parseFloat('22.34.5');		// 22.34
  ```

- **除首个小数点有效之外，`parseFloat()`与 `parseInt()`的第二个区别在于它始终会忽略前导的零；**

  ```JS
  parseFloat('010');			// 10
  parseFloat('0908.5');		// 908.5
  ```

-  **`parseFloat()`只解析十进制值，因为它没有用第二个参数指定基数的用法；**

- **十六进制格式的字符串始终会转换为0；**

  ```js
  parseFloat('0xf');		// NaN
  ```

- **如果字符串中包含一个可解析为整数的数（没有小数点，或小数点后都是零）， `parseFloat()`会返回整数；**

  ```js
  parseFloat('1234blue');		// 1234
  parseFloat('3.125e7');		// 31250000
  ```

  

